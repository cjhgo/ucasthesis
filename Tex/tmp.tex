
\begin{center}
  \includegraphics[width=0.8\textwidth]{Figure/ca-active.png}
  \captionof{figure}{roadNet-CA上的活跃点变化示意图}
  \label{fig:ca-active}
\end{center}  

图\ref{fig:use-active}则具体给出了延迟一致方法中每轮迭代进行有效计算的点的数量和比例。
可以看到，延迟一致方法每轮迭代的有效计算的比例呈现一个U形曲线，即一开始有效计算占比较高达到80\%，
随着迭代的进行，比例下降，随后又上升。
如果观察具体的有效计算的点的数量，那么可以看到总是远高于同步引擎中每轮迭代的活跃点的数量的。
也就是说，在roadNet-CA这个图上执行sssp算法时，延迟一致方法的有效计算比例呈现U形波动变化，
但是在多数情况下都能能比同步引擎激活且有效地计算更多的活跃点。  
从最终的计算时间上来看，延迟一致性方法经过138轮迭代耗时43s完成了计算，而同步引擎经过555轮迭代耗时134s完成了计算。
延迟一致方法取得了3倍的加速比。

\begin{center}
  \includegraphics[width=0.8\textwidth]{Figure/use-active.png}
  \captionof{figure}{roadNet-CA上的活跃点变化示意图}
  \label{fig:use-active}
\end{center}  

在roadNet-CA上我们从一开始就开启了延迟一致性策略，并取得了很好的加速比。
但在有些图上，我们延迟一致性要稍晚一点开启，比如在enwiki这个图上。
enwiki同样是来自snap数据集的一个大图，由1亿条边和400万个顶点构成。
在enwiki上执行sssp算法，使用同步引擎需要53轮迭代耗时18s。
使用延迟一致方法，如果一开始就开启延迟一致完成计算需要39轮迭代耗时19s，
而如果推迟到第8轮迭代再开启延迟一致，则完成计算需要40轮迭代耗时13s。
可以看到，如果一开始就开启延迟一致，虽然也能够减少迭代轮次，但总时间并没有减少，
推迟开启之后，在减少迭代轮次的基础上同样减少了总的计算时间。

得到了如下结果。
roadNet-CA是来自snap数据集的一个大图，由550万条边和200个点构成。
图\ref{fig:ca-active}中给出了在这个图上分别采用同步引擎和延迟一致方法进行sssp计算时，活跃点的变化曲线。
可以看到相较于同步引擎，延迟一致方法每一轮迭代都有更多的活跃点，并且最终以更少的迭代次数结束了计算。